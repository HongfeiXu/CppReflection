#pragma once

#include <string>
#include <iostream>
#include <map>


// 所有需要实现反射的类需要继承它
class ReflectObject {
public:
	virtual ~ReflectObject(){}
};


// 对象工厂抽象类，用来生成对象实例
class ObjectFactory {
public:
	ObjectFactory() { std::cout << "ObjectFactory()" << std::endl; }
	virtual ~ObjectFactory() { std::cout << "~ObjectFactory()" << std::endl; }
	virtual ReflectObject* newInstance() = 0;
};


// 反射器，用来管理（对象名，对象工厂）的映射关系
class Reflector
{
public:
	Reflector();
	~Reflector();
	void registerFactory(const std::string& className, ObjectFactory* of);
	ReflectObject* getNewInstance(const std::string& className);
private:
	std::map<std::string, ObjectFactory*> objectFactories;
};


// 获取反射器实例，全局唯一
Reflector& reflector();


// 要被反射的类，需要在其对应的 cpp 文件中进行反射声明
#define REFLECT(name)\
class ObjectFactory_##name : public ObjectFactory{\
public:\
	ObjectFactory_##name(){ std::cout << "ObjectFactory_" << #name << "()" << std::endl; }\
	virtual ~ObjectFactory_##name(){ std::cout << "~ObjectFactory_" << #name << "()" << std::endl; }\
	ReflectObject* newInstance() {\
		return new name(); \
	}\
}; \
class Register_##name{\
public:\
	Register_##name(){\
		reflector().registerFactory(#name, new ObjectFactory_##name()); \
	}\
};\
Register_##name register_##name;

// 根据类名获取对象实例
template<typename T>
T* getNewInstance(const std::string& className) {
	return dynamic_cast<T*>(reflector().getNewInstance(className));
}

// 说明，上述反射声明REFLECT(Allen) 等价于如下两个步骤

/*
// 步骤 1 定义类Allen的工厂类
class ObjectFactory_Allen : public ObjectFactory {
	ReflectObject* newInstance() {
		return new Allen();
	};
}

// 步骤 2 创建Allen工厂实例对象，并注册侧到反射器中
reflector().registerFactory("Allen", new ObjectFactory_Allen());
*/